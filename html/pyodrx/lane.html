<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>pyodrx.lane API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pyodrx.lane</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import xml.etree.ElementTree as ET
from .helpers import enum2str
from .enumerations import LaneType, LaneChange, RoadMarkWeight, RoadMarkColor, RoadMarkType 
from .links import _Links,_Link


class Lanes():
    &#34;&#34;&#34; creates the Lanes element of opendrive
    

        Attributes
        ----------
            lane_sections (list of LaneSection): a list of all lanesections

        Methods
        -------
            get_element(elementname)
                Returns the full ElementTree of the class

            add_lanesection(lanesection)
                adds a lane section to Lanes
    &#34;&#34;&#34;
    def __init__(self):
        &#34;&#34;&#34; initalize Lanes

        &#34;&#34;&#34;
        self.lanesections = []
    def add_lanesection(self,lanesection, lanelinks=None):
        &#34;&#34;&#34; creates the Lanes element of opendrive
    

        Parameters
        ----------
            lanesection (LaneSection): a LaneSection to add

            lanelink (LaneLinker): (optional) a LaneLink to add 

        &#34;&#34;&#34;
        # add links to the lanes
        if lanelinks: 
            #loop over all links 
            if not isinstance(lanelinks, list):
                lanelinks = [lanelinks]
            for lanelink in lanelinks:
                for link in lanelink.links:
                    # check if link already added 
                    if not link.used:
                        link.predecessor.add_link(&#39;successor&#39;,link.lane_id)
                        link.successor.add_link(&#39;predecessor&#39;,link[0].lane_id)
                        link.used = True
          
        self.lanesections.append(lanesection)

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of Lanes

        &#34;&#34;&#34;
        element = ET.Element(&#39;lanes&#39;)
        for l in self.lanesections:
            element.append(l.get_element())
        return element

class LaneSection():
    &#34;&#34;&#34; Creates the LaneSection element of opendrive

        Parameters
        ----------
            s (float): start of lanesection

            centerlane (Lane): the centerline of the road

        Attributes
        ----------
            s (float): start of lanesection

            centerlane (Lane): the centerline of the road

            leftlanes (list of Lane): the lanes left to the center

            rightlanes (list of Lane): the lanes right to the center

        Methods
        -------
            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of class

            add_left_lane(Lane)
                adds a new lane to the left

            add_right_lane(Lane)
                adds a new lane to the right
    &#34;&#34;&#34;

    def __init__(self,s,centerlane):
        &#34;&#34;&#34; initalize the LaneSection

            Parameters
            ----------
                s (float): start of lanesection

                centerlane (Lane): the centerline of the road
        &#34;&#34;&#34;
        self.s = s
        self.centerlane = centerlane
        self.centerlane._set_lane_id(0)
        self.leftlanes = []
        self.rightlanes = []
        self._left_id = 1
        self._right_id = -1


    def add_left_lane(self,lane):
        &#34;&#34;&#34; adds a lane to the left of the center, add from center outwards

            Parameters
            ----------
                lane (Lane): the lane to add
        &#34;&#34;&#34;
        lane._set_lane_id(self._left_id)
        self._left_id += 1
        self.leftlanes.append(lane)
    
    def add_right_lane(self,lane):
        &#34;&#34;&#34; adds a lane to the right of the center, add from center outwards

            Parameters
            ----------
                lane (Lane): the lane to add
        &#34;&#34;&#34;
        lane._set_lane_id(self._right_id)
        self._right_id -= 1
        self.rightlanes.append(lane)

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the Lane as a dict

        &#34;&#34;&#34;
        retdict = {}
        retdict[&#39;s&#39;] = str(self.s)
        return retdict

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the WorldPostion

        &#34;&#34;&#34;
        element = ET.Element(&#39;laneSection&#39;,attrib=self.get_attributes())

        if self.leftlanes:
            left = ET.SubElement(element,&#39;left&#39;)
            for l in self.leftlanes:
                left.append(l.get_element())


        center = ET.SubElement(element,&#39;center&#39;)
        center.append(self.centerlane.get_element())

        if self.rightlanes:
            right = ET.SubElement(element,&#39;right&#39;)
            for l in self.rightlanes:
                right.append(l.get_element())

        return element
        

class Lane():
    &#34;&#34;&#34; creates a Lane of opendrive

        the inputs are on the following format:
            f(s) = a + b*s + c*s^2 + d*s^3

        Parameters
        ----------
            
            lane_type (LaneType): type of lane
                Default: LaneType.driving

            a (float): a coefficient
                Default: 0

            b (float): b coefficient
                Default: 0

            c (float): c coefficient
                Default: 0

            d (float): d coefficient
                Default: 0

            soffset (float): soffset of lane
                Default: 0


        Attributes
        ----------
            lane_id (int): id of the lane (automatically assigned by LaneSection)
            
            lane_type (LaneType): type of lane

            a (float): a coefficient

            b (float): b coefficient

            c (float): c coefficient

            d (float): d coefficient

            soffset (float): soffset of lane

            roadmark (RoadMark): roadmarks related to the lane

            links (_Links): Lane links to the lane

        Methods
        -------
            get_element(elementname)
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of class

            add_roadmark(roadmark)
                adds a new roadmark to the lane

    &#34;&#34;&#34;
    def __init__(self,lane_type=LaneType.driving,a=0,b=0,c=0,d=0,soffset=0):
        &#34;&#34;&#34; initalizes the Lane

        Parameters
        ----------
            
            lane_type (LaneType): type of lane
                Default: LaneType.driving

            a (float): a coefficient
                Default: 0

            b (float): b coefficient
                Default: 0

            c (float): c coefficient
                Default: 0

            d (float): d coefficient
                Default: 0

            soffset (float): soffset of lane
                Default: 0

        &#34;&#34;&#34; 
        self.lane_id = None
        self.lane_type = lane_type
        self.a = a
        self.b = b
        self.c = c
        self.d = d
        self.soffset = soffset
        self.roadmark = None
        self.links = _Links()

        
        #TODO: add more features to add for lane
    def add_link(self,link_type,id):
        &#34;&#34;&#34; adds a link to the lane section

        Parameters
        ----------
            link_type (str): type of link, successor or predecessor

            id (str/id): id of the linked lane
        &#34;&#34;&#34;
        self.links.add_link(_Link(link_type,str(id)))

    def _set_lane_id(self,lane_id):
        &#34;&#34;&#34; set the lane id of the lane

        &#34;&#34;&#34;
        self.lane_id = lane_id

    def add_roadmark(self,roadmark):
        &#34;&#34;&#34; add_roadmark adds a roadmark to the lane
        
        Parameters
        ----------
            roadmark (RoadMark): roadmark of the lane

        &#34;&#34;&#34;
        self.roadmark = roadmark
        

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the Lane as a dict

        &#34;&#34;&#34;
        retdict = {}
        if self.lane_id == None:
            raise ValueError(&#39;lane id is not set correctly.&#39;)
        retdict[&#39;id&#39;] = str(self.lane_id)
        retdict[&#39;type&#39;] = enum2str(self.lane_type)
        retdict[&#39;level&#39;] = &#39;false&#39;
        return retdict

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the WorldPostion

        &#34;&#34;&#34;
        element = ET.Element(&#39;lane&#39;,attrib=self.get_attributes())
        element.append(self.links.get_element())

        widthdict = {}
        widthdict[&#39;a&#39;] = str(self.a)
        widthdict[&#39;b&#39;] = str(self.b)
        widthdict[&#39;c&#39;] = str(self.c)
        widthdict[&#39;d&#39;] = str(self.d)
        widthdict[&#39;sOffset&#39;] = str(self.soffset)

        ET.SubElement(element,&#39;width&#39;,attrib=widthdict)
        if self.roadmark:
            element.append(self.roadmark.get_element())
        return element




class RoadLine():
    &#34;&#34;&#34; creates a Line type of to be used in roadmark

        Parameters
        ----------
            width (float): with of the line
                Default: 0
            length (float): length of the line
                Default: 0
            space (float): length of space between (broken) lines
                Default: 0
            toffset (float): offset in t
                Default: 0
            soffset (float): offset in s
                Default: 0
            rule (MarkRule): mark rule (optional)

            color (RoadMarkColor): color of line (optional)

        Attributes
        ----------
            length (float): length of the line

            space (float): length of space between (broken) lines

            toffset (float): offset in t

            soffset (float): offset in s

            rule (MarkRule): mark rule

            width (float): with of the line

            color (RoadMarkColor): color of line

        Methods
        -------
            get_element(elementname)
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of FileHeader

    &#34;&#34;&#34;
    # TODO: check this for 1.5
    def __init__(self,width = 0,length=0,space=0,toffset=0,soffset=0,rule=None,color=None):
        &#34;&#34;&#34; initalizes the RoadLine

        Parameters
        ----------
            width (float): with of the line
                Default: 0
            length (float): length of the line
                Default: 0
            space (float): length of space between (broken) lines
                Default: 0
            toffset (float): offset in t
                Default: 0
            soffset (float): offset in s
                Default: 0
            rule (MarkRule): mark rule (optional)

            color (RoadMarkColor): color of line (optional)


        &#34;&#34;&#34; 
        self.length = length
        self.space = space
        self.toffset = toffset
        self.rule = rule
        self.soffset = soffset
        self.width = width
        self.color = color



        

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the Lane as a dict

        &#34;&#34;&#34;
        retdict = {}
        retdict[&#39;length&#39;] = str(self.length)
        retdict[&#39;space&#39;] = str(self.space)
        retdict[&#39;tOffset&#39;] = str(self.toffset)
        retdict[&#39;width&#39;] = str(self.width)
        retdict[&#39;sOffset&#39;] = str(self.soffset)
        # if self.color:
            # retdict[&#39;color&#39;] = enum2str(self.color)
        if self.rule:
            retdict[&#39;rule&#39;] = enum2str(self.rule)
        return retdict

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the WorldPostion

        &#34;&#34;&#34;
        element = ET.Element(&#39;line&#39;,attrib=self.get_attributes())
        return element


class RoadMark():
    &#34;&#34;&#34; creates a RoadMark of opendrive

        Parameters
        ----------
            marking_type (RoadMarkType): the type of marking

            width (float): with of the line

            length (float): length of the line
                Default: 0
            toffset (float): offset in t
                Default: 0
            soffset (float): offset in s
                Default: 0
            rule (MarkRule): mark rule (optional)

            color (RoadMarkColor): color of line (optional)

        Attributes
        ----------
            marking_type (str): the type of marking

            width (float): with of the line

            length (float): length of the line
                Default: 0
            toffset (float): offset in t
                Default: 0
            soffset (float): offset in s
                Default: 0
            rule (MarkRule): mark rule (optional)

            color (RoadMarkColor): color of line (optional)

        Methods
        -------
            get_element(elementname)
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of FileHeader

            add_roadmark(roadmark)
                adds a new roadmark to the lane

    &#34;&#34;&#34;
    def __init__(self,marking_type,width,length=0,space=0,toffset=0,soffset=0,rule=None,color=RoadMarkColor.standard):
        &#34;&#34;&#34; initalizes the Lane

        Parameters
        ----------
            marking_type (str): the type of marking

            width (float): with of the line

            length (float): length of the line
                Default: 0
            toffset (float): offset in t
                Default: 0
            soffset (float): offset in s
                Default: 0
            rule (MarkRule): mark rule (optional)

            color (RoadMarkColor): color of line
                Default: &#39;standard&#39;

        &#34;&#34;&#34; 
        self.marking_type = marking_type
        self.length = length
        self.space = space
        self.toffset = toffset
        self.rule = rule
        self.soffset = soffset
        self.width = width
        self.color = color
        #change default line values for broken lines 
        if marking_type == RoadMarkType.broken: 
            if self.length == 0:
                self.length = 3
            if self.space == 0: 
                self.space = 3
        self._line = RoadLine(self.width,self.length,self.space,self.toffset,self.soffset,self.rule,self.color)
        
        #TODO: add more inputs and check 1.5
        

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the Lane as a dict

        &#34;&#34;&#34;
        retdict = {}
        retdict[&#39;sOffset&#39;] = str(self.soffset)
        retdict[&#39;type&#39;] = enum2str(self.marking_type)
        retdict[&#39;weight&#39;] = enum2str(RoadMarkWeight.standard)
        retdict[&#39;color&#39;] = enum2str(self.color)
        retdict[&#39;sOffset&#39;] = str(self.soffset)
        retdict[&#39;width&#39;] = str(self.width)
        retdict[&#39;laneChange&#39;] = enum2str(LaneChange.none)
        retdict[&#39;height&#39;] = str(2e-02)
        return retdict

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the WorldPostion

        &#34;&#34;&#34;
        element = ET.Element(&#39;roadMark&#39;,attrib=self.get_attributes())
        typeelement = ET.SubElement(element,&#39;type&#39;, attrib={&#39;name&#39;:enum2str(self.marking_type),&#39;width&#39;:str(self.width)})
        typeelement.append(self._line.get_element())
        return element</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pyodrx.lane.Lane"><code class="flex name class">
<span>class <span class="ident">Lane</span></span>
<span>(</span><span>lane_type=LaneType.driving, a=0, b=0, c=0, d=0, soffset=0)</span>
</code></dt>
<dd>
<div class="desc"><p>creates a Lane of opendrive</p>
<p>the inputs are on the following format:
f(s) = a + b<em>s + c</em>s^2 + d*s^3</p>
<h2 id="parameters">Parameters</h2>
<pre><code>lane_type (LaneType): type of lane
    Default: LaneType.driving

a (float): a coefficient
    Default: 0

b (float): b coefficient
    Default: 0

c (float): c coefficient
    Default: 0

d (float): d coefficient
    Default: 0

soffset (float): soffset of lane
    Default: 0
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>lane_id (int): id of the lane (automatically assigned by LaneSection)

lane_type (LaneType): type of lane

a (float): a coefficient

b (float): b coefficient

c (float): c coefficient

d (float): d coefficient

soffset (float): soffset of lane

roadmark (RoadMark): roadmarks related to the lane

links (_Links): Lane links to the lane
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>get_element(elementname)
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of class

add_roadmark(roadmark)
    adds a new roadmark to the lane
</code></pre>
<p>initalizes the Lane</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>lane_type (LaneType): type of lane
    Default: LaneType.driving

a (float): a coefficient
    Default: 0

b (float): b coefficient
    Default: 0

c (float): c coefficient
    Default: 0

d (float): d coefficient
    Default: 0

soffset (float): soffset of lane
    Default: 0
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Lane():
    &#34;&#34;&#34; creates a Lane of opendrive

        the inputs are on the following format:
            f(s) = a + b*s + c*s^2 + d*s^3

        Parameters
        ----------
            
            lane_type (LaneType): type of lane
                Default: LaneType.driving

            a (float): a coefficient
                Default: 0

            b (float): b coefficient
                Default: 0

            c (float): c coefficient
                Default: 0

            d (float): d coefficient
                Default: 0

            soffset (float): soffset of lane
                Default: 0


        Attributes
        ----------
            lane_id (int): id of the lane (automatically assigned by LaneSection)
            
            lane_type (LaneType): type of lane

            a (float): a coefficient

            b (float): b coefficient

            c (float): c coefficient

            d (float): d coefficient

            soffset (float): soffset of lane

            roadmark (RoadMark): roadmarks related to the lane

            links (_Links): Lane links to the lane

        Methods
        -------
            get_element(elementname)
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of class

            add_roadmark(roadmark)
                adds a new roadmark to the lane

    &#34;&#34;&#34;
    def __init__(self,lane_type=LaneType.driving,a=0,b=0,c=0,d=0,soffset=0):
        &#34;&#34;&#34; initalizes the Lane

        Parameters
        ----------
            
            lane_type (LaneType): type of lane
                Default: LaneType.driving

            a (float): a coefficient
                Default: 0

            b (float): b coefficient
                Default: 0

            c (float): c coefficient
                Default: 0

            d (float): d coefficient
                Default: 0

            soffset (float): soffset of lane
                Default: 0

        &#34;&#34;&#34; 
        self.lane_id = None
        self.lane_type = lane_type
        self.a = a
        self.b = b
        self.c = c
        self.d = d
        self.soffset = soffset
        self.roadmark = None
        self.links = _Links()

        
        #TODO: add more features to add for lane
    def add_link(self,link_type,id):
        &#34;&#34;&#34; adds a link to the lane section

        Parameters
        ----------
            link_type (str): type of link, successor or predecessor

            id (str/id): id of the linked lane
        &#34;&#34;&#34;
        self.links.add_link(_Link(link_type,str(id)))

    def _set_lane_id(self,lane_id):
        &#34;&#34;&#34; set the lane id of the lane

        &#34;&#34;&#34;
        self.lane_id = lane_id

    def add_roadmark(self,roadmark):
        &#34;&#34;&#34; add_roadmark adds a roadmark to the lane
        
        Parameters
        ----------
            roadmark (RoadMark): roadmark of the lane

        &#34;&#34;&#34;
        self.roadmark = roadmark
        

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the Lane as a dict

        &#34;&#34;&#34;
        retdict = {}
        if self.lane_id == None:
            raise ValueError(&#39;lane id is not set correctly.&#39;)
        retdict[&#39;id&#39;] = str(self.lane_id)
        retdict[&#39;type&#39;] = enum2str(self.lane_type)
        retdict[&#39;level&#39;] = &#39;false&#39;
        return retdict

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the WorldPostion

        &#34;&#34;&#34;
        element = ET.Element(&#39;lane&#39;,attrib=self.get_attributes())
        element.append(self.links.get_element())

        widthdict = {}
        widthdict[&#39;a&#39;] = str(self.a)
        widthdict[&#39;b&#39;] = str(self.b)
        widthdict[&#39;c&#39;] = str(self.c)
        widthdict[&#39;d&#39;] = str(self.d)
        widthdict[&#39;sOffset&#39;] = str(self.soffset)

        ET.SubElement(element,&#39;width&#39;,attrib=widthdict)
        if self.roadmark:
            element.append(self.roadmark.get_element())
        return element</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pyodrx.lane.Lane.add_link"><code class="name flex">
<span>def <span class="ident">add_link</span></span>(<span>self, link_type, id)</span>
</code></dt>
<dd>
<div class="desc"><p>adds a link to the lane section</p>
<h2 id="parameters">Parameters</h2>
<pre><code>link_type (str): type of link, successor or predecessor

id (str/id): id of the linked lane
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_link(self,link_type,id):
    &#34;&#34;&#34; adds a link to the lane section

    Parameters
    ----------
        link_type (str): type of link, successor or predecessor

        id (str/id): id of the linked lane
    &#34;&#34;&#34;
    self.links.add_link(_Link(link_type,str(id)))</code></pre>
</details>
</dd>
<dt id="pyodrx.lane.Lane.add_roadmark"><code class="name flex">
<span>def <span class="ident">add_roadmark</span></span>(<span>self, roadmark)</span>
</code></dt>
<dd>
<div class="desc"><p>add_roadmark adds a roadmark to the lane</p>
<h2 id="parameters">Parameters</h2>
<pre><code>roadmark (RoadMark): roadmark of the lane
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_roadmark(self,roadmark):
    &#34;&#34;&#34; add_roadmark adds a roadmark to the lane
    
    Parameters
    ----------
        roadmark (RoadMark): roadmark of the lane

    &#34;&#34;&#34;
    self.roadmark = roadmark</code></pre>
</details>
</dd>
<dt id="pyodrx.lane.Lane.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the Lane as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34; returns the attributes of the Lane as a dict

    &#34;&#34;&#34;
    retdict = {}
    if self.lane_id == None:
        raise ValueError(&#39;lane id is not set correctly.&#39;)
    retdict[&#39;id&#39;] = str(self.lane_id)
    retdict[&#39;type&#39;] = enum2str(self.lane_type)
    retdict[&#39;level&#39;] = &#39;false&#39;
    return retdict</code></pre>
</details>
</dd>
<dt id="pyodrx.lane.Lane.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the WorldPostion</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34; returns the elementTree of the WorldPostion

    &#34;&#34;&#34;
    element = ET.Element(&#39;lane&#39;,attrib=self.get_attributes())
    element.append(self.links.get_element())

    widthdict = {}
    widthdict[&#39;a&#39;] = str(self.a)
    widthdict[&#39;b&#39;] = str(self.b)
    widthdict[&#39;c&#39;] = str(self.c)
    widthdict[&#39;d&#39;] = str(self.d)
    widthdict[&#39;sOffset&#39;] = str(self.soffset)

    ET.SubElement(element,&#39;width&#39;,attrib=widthdict)
    if self.roadmark:
        element.append(self.roadmark.get_element())
    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyodrx.lane.LaneSection"><code class="flex name class">
<span>class <span class="ident">LaneSection</span></span>
<span>(</span><span>s, centerlane)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates the LaneSection element of opendrive</p>
<h2 id="parameters">Parameters</h2>
<pre><code>s (float): start of lanesection

centerlane (Lane): the centerline of the road
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>s (float): start of lanesection

centerlane (Lane): the centerline of the road

leftlanes (list of Lane): the lanes left to the center

rightlanes (list of Lane): the lanes right to the center
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>get_element()
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of class

add_left_lane(Lane)
    adds a new lane to the left

add_right_lane(Lane)
    adds a new lane to the right
</code></pre>
<p>initalize the LaneSection</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>s (float): start of lanesection

centerlane (Lane): the centerline of the road
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LaneSection():
    &#34;&#34;&#34; Creates the LaneSection element of opendrive

        Parameters
        ----------
            s (float): start of lanesection

            centerlane (Lane): the centerline of the road

        Attributes
        ----------
            s (float): start of lanesection

            centerlane (Lane): the centerline of the road

            leftlanes (list of Lane): the lanes left to the center

            rightlanes (list of Lane): the lanes right to the center

        Methods
        -------
            get_element()
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of class

            add_left_lane(Lane)
                adds a new lane to the left

            add_right_lane(Lane)
                adds a new lane to the right
    &#34;&#34;&#34;

    def __init__(self,s,centerlane):
        &#34;&#34;&#34; initalize the LaneSection

            Parameters
            ----------
                s (float): start of lanesection

                centerlane (Lane): the centerline of the road
        &#34;&#34;&#34;
        self.s = s
        self.centerlane = centerlane
        self.centerlane._set_lane_id(0)
        self.leftlanes = []
        self.rightlanes = []
        self._left_id = 1
        self._right_id = -1


    def add_left_lane(self,lane):
        &#34;&#34;&#34; adds a lane to the left of the center, add from center outwards

            Parameters
            ----------
                lane (Lane): the lane to add
        &#34;&#34;&#34;
        lane._set_lane_id(self._left_id)
        self._left_id += 1
        self.leftlanes.append(lane)
    
    def add_right_lane(self,lane):
        &#34;&#34;&#34; adds a lane to the right of the center, add from center outwards

            Parameters
            ----------
                lane (Lane): the lane to add
        &#34;&#34;&#34;
        lane._set_lane_id(self._right_id)
        self._right_id -= 1
        self.rightlanes.append(lane)

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the Lane as a dict

        &#34;&#34;&#34;
        retdict = {}
        retdict[&#39;s&#39;] = str(self.s)
        return retdict

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the WorldPostion

        &#34;&#34;&#34;
        element = ET.Element(&#39;laneSection&#39;,attrib=self.get_attributes())

        if self.leftlanes:
            left = ET.SubElement(element,&#39;left&#39;)
            for l in self.leftlanes:
                left.append(l.get_element())


        center = ET.SubElement(element,&#39;center&#39;)
        center.append(self.centerlane.get_element())

        if self.rightlanes:
            right = ET.SubElement(element,&#39;right&#39;)
            for l in self.rightlanes:
                right.append(l.get_element())

        return element</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pyodrx.lane.LaneSection.add_left_lane"><code class="name flex">
<span>def <span class="ident">add_left_lane</span></span>(<span>self, lane)</span>
</code></dt>
<dd>
<div class="desc"><p>adds a lane to the left of the center, add from center outwards</p>
<h2 id="parameters">Parameters</h2>
<pre><code>lane (Lane): the lane to add
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_left_lane(self,lane):
    &#34;&#34;&#34; adds a lane to the left of the center, add from center outwards

        Parameters
        ----------
            lane (Lane): the lane to add
    &#34;&#34;&#34;
    lane._set_lane_id(self._left_id)
    self._left_id += 1
    self.leftlanes.append(lane)</code></pre>
</details>
</dd>
<dt id="pyodrx.lane.LaneSection.add_right_lane"><code class="name flex">
<span>def <span class="ident">add_right_lane</span></span>(<span>self, lane)</span>
</code></dt>
<dd>
<div class="desc"><p>adds a lane to the right of the center, add from center outwards</p>
<h2 id="parameters">Parameters</h2>
<pre><code>lane (Lane): the lane to add
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_right_lane(self,lane):
    &#34;&#34;&#34; adds a lane to the right of the center, add from center outwards

        Parameters
        ----------
            lane (Lane): the lane to add
    &#34;&#34;&#34;
    lane._set_lane_id(self._right_id)
    self._right_id -= 1
    self.rightlanes.append(lane)</code></pre>
</details>
</dd>
<dt id="pyodrx.lane.LaneSection.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the Lane as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34; returns the attributes of the Lane as a dict

    &#34;&#34;&#34;
    retdict = {}
    retdict[&#39;s&#39;] = str(self.s)
    return retdict</code></pre>
</details>
</dd>
<dt id="pyodrx.lane.LaneSection.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the WorldPostion</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34; returns the elementTree of the WorldPostion

    &#34;&#34;&#34;
    element = ET.Element(&#39;laneSection&#39;,attrib=self.get_attributes())

    if self.leftlanes:
        left = ET.SubElement(element,&#39;left&#39;)
        for l in self.leftlanes:
            left.append(l.get_element())


    center = ET.SubElement(element,&#39;center&#39;)
    center.append(self.centerlane.get_element())

    if self.rightlanes:
        right = ET.SubElement(element,&#39;right&#39;)
        for l in self.rightlanes:
            right.append(l.get_element())

    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyodrx.lane.Lanes"><code class="flex name class">
<span>class <span class="ident">Lanes</span></span>
</code></dt>
<dd>
<div class="desc"><p>creates the Lanes element of opendrive</p>
<h2 id="attributes">Attributes</h2>
<pre><code>lane_sections (list of LaneSection): a list of all lanesections
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>get_element(elementname)
    Returns the full ElementTree of the class

add_lanesection(lanesection)
    adds a lane section to Lanes
</code></pre>
<p>initalize Lanes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Lanes():
    &#34;&#34;&#34; creates the Lanes element of opendrive
    

        Attributes
        ----------
            lane_sections (list of LaneSection): a list of all lanesections

        Methods
        -------
            get_element(elementname)
                Returns the full ElementTree of the class

            add_lanesection(lanesection)
                adds a lane section to Lanes
    &#34;&#34;&#34;
    def __init__(self):
        &#34;&#34;&#34; initalize Lanes

        &#34;&#34;&#34;
        self.lanesections = []
    def add_lanesection(self,lanesection, lanelinks=None):
        &#34;&#34;&#34; creates the Lanes element of opendrive
    

        Parameters
        ----------
            lanesection (LaneSection): a LaneSection to add

            lanelink (LaneLinker): (optional) a LaneLink to add 

        &#34;&#34;&#34;
        # add links to the lanes
        if lanelinks: 
            #loop over all links 
            if not isinstance(lanelinks, list):
                lanelinks = [lanelinks]
            for lanelink in lanelinks:
                for link in lanelink.links:
                    # check if link already added 
                    if not link.used:
                        link.predecessor.add_link(&#39;successor&#39;,link.lane_id)
                        link.successor.add_link(&#39;predecessor&#39;,link[0].lane_id)
                        link.used = True
          
        self.lanesections.append(lanesection)

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of Lanes

        &#34;&#34;&#34;
        element = ET.Element(&#39;lanes&#39;)
        for l in self.lanesections:
            element.append(l.get_element())
        return element</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pyodrx.lane.Lanes.add_lanesection"><code class="name flex">
<span>def <span class="ident">add_lanesection</span></span>(<span>self, lanesection, lanelinks=None)</span>
</code></dt>
<dd>
<div class="desc"><p>creates the Lanes element of opendrive</p>
<h2 id="parameters">Parameters</h2>
<pre><code>lanesection (LaneSection): a LaneSection to add

lanelink (LaneLinker): (optional) a LaneLink to add
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_lanesection(self,lanesection, lanelinks=None):
    &#34;&#34;&#34; creates the Lanes element of opendrive


    Parameters
    ----------
        lanesection (LaneSection): a LaneSection to add

        lanelink (LaneLinker): (optional) a LaneLink to add 

    &#34;&#34;&#34;
    # add links to the lanes
    if lanelinks: 
        #loop over all links 
        if not isinstance(lanelinks, list):
            lanelinks = [lanelinks]
        for lanelink in lanelinks:
            for link in lanelink.links:
                # check if link already added 
                if not link.used:
                    link.predecessor.add_link(&#39;successor&#39;,link.lane_id)
                    link.successor.add_link(&#39;predecessor&#39;,link[0].lane_id)
                    link.used = True
      
    self.lanesections.append(lanesection)</code></pre>
</details>
</dd>
<dt id="pyodrx.lane.Lanes.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of Lanes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34; returns the elementTree of Lanes

    &#34;&#34;&#34;
    element = ET.Element(&#39;lanes&#39;)
    for l in self.lanesections:
        element.append(l.get_element())
    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyodrx.lane.RoadLine"><code class="flex name class">
<span>class <span class="ident">RoadLine</span></span>
<span>(</span><span>width=0, length=0, space=0, toffset=0, soffset=0, rule=None, color=None)</span>
</code></dt>
<dd>
<div class="desc"><p>creates a Line type of to be used in roadmark</p>
<h2 id="parameters">Parameters</h2>
<pre><code>width (float): with of the line
    Default: 0
length (float): length of the line
    Default: 0
space (float): length of space between (broken) lines
    Default: 0
toffset (float): offset in t
    Default: 0
soffset (float): offset in s
    Default: 0
rule (MarkRule): mark rule (optional)

color (RoadMarkColor): color of line (optional)
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>length (float): length of the line

space (float): length of space between (broken) lines

toffset (float): offset in t

soffset (float): offset in s

rule (MarkRule): mark rule

width (float): with of the line

color (RoadMarkColor): color of line
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>get_element(elementname)
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of FileHeader
</code></pre>
<p>initalizes the RoadLine</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>width (float): with of the line
    Default: 0
length (float): length of the line
    Default: 0
space (float): length of space between (broken) lines
    Default: 0
toffset (float): offset in t
    Default: 0
soffset (float): offset in s
    Default: 0
rule (MarkRule): mark rule (optional)

color (RoadMarkColor): color of line (optional)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RoadLine():
    &#34;&#34;&#34; creates a Line type of to be used in roadmark

        Parameters
        ----------
            width (float): with of the line
                Default: 0
            length (float): length of the line
                Default: 0
            space (float): length of space between (broken) lines
                Default: 0
            toffset (float): offset in t
                Default: 0
            soffset (float): offset in s
                Default: 0
            rule (MarkRule): mark rule (optional)

            color (RoadMarkColor): color of line (optional)

        Attributes
        ----------
            length (float): length of the line

            space (float): length of space between (broken) lines

            toffset (float): offset in t

            soffset (float): offset in s

            rule (MarkRule): mark rule

            width (float): with of the line

            color (RoadMarkColor): color of line

        Methods
        -------
            get_element(elementname)
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of FileHeader

    &#34;&#34;&#34;
    # TODO: check this for 1.5
    def __init__(self,width = 0,length=0,space=0,toffset=0,soffset=0,rule=None,color=None):
        &#34;&#34;&#34; initalizes the RoadLine

        Parameters
        ----------
            width (float): with of the line
                Default: 0
            length (float): length of the line
                Default: 0
            space (float): length of space between (broken) lines
                Default: 0
            toffset (float): offset in t
                Default: 0
            soffset (float): offset in s
                Default: 0
            rule (MarkRule): mark rule (optional)

            color (RoadMarkColor): color of line (optional)


        &#34;&#34;&#34; 
        self.length = length
        self.space = space
        self.toffset = toffset
        self.rule = rule
        self.soffset = soffset
        self.width = width
        self.color = color



        

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the Lane as a dict

        &#34;&#34;&#34;
        retdict = {}
        retdict[&#39;length&#39;] = str(self.length)
        retdict[&#39;space&#39;] = str(self.space)
        retdict[&#39;tOffset&#39;] = str(self.toffset)
        retdict[&#39;width&#39;] = str(self.width)
        retdict[&#39;sOffset&#39;] = str(self.soffset)
        # if self.color:
            # retdict[&#39;color&#39;] = enum2str(self.color)
        if self.rule:
            retdict[&#39;rule&#39;] = enum2str(self.rule)
        return retdict

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the WorldPostion

        &#34;&#34;&#34;
        element = ET.Element(&#39;line&#39;,attrib=self.get_attributes())
        return element</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pyodrx.lane.RoadLine.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the Lane as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34; returns the attributes of the Lane as a dict

    &#34;&#34;&#34;
    retdict = {}
    retdict[&#39;length&#39;] = str(self.length)
    retdict[&#39;space&#39;] = str(self.space)
    retdict[&#39;tOffset&#39;] = str(self.toffset)
    retdict[&#39;width&#39;] = str(self.width)
    retdict[&#39;sOffset&#39;] = str(self.soffset)
    # if self.color:
        # retdict[&#39;color&#39;] = enum2str(self.color)
    if self.rule:
        retdict[&#39;rule&#39;] = enum2str(self.rule)
    return retdict</code></pre>
</details>
</dd>
<dt id="pyodrx.lane.RoadLine.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the WorldPostion</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34; returns the elementTree of the WorldPostion

    &#34;&#34;&#34;
    element = ET.Element(&#39;line&#39;,attrib=self.get_attributes())
    return element</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyodrx.lane.RoadMark"><code class="flex name class">
<span>class <span class="ident">RoadMark</span></span>
<span>(</span><span>marking_type, width, length=0, space=0, toffset=0, soffset=0, rule=None, color=RoadMarkColor.standard)</span>
</code></dt>
<dd>
<div class="desc"><p>creates a RoadMark of opendrive</p>
<h2 id="parameters">Parameters</h2>
<pre><code>marking_type (RoadMarkType): the type of marking

width (float): with of the line

length (float): length of the line
    Default: 0
toffset (float): offset in t
    Default: 0
soffset (float): offset in s
    Default: 0
rule (MarkRule): mark rule (optional)

color (RoadMarkColor): color of line (optional)
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>marking_type (str): the type of marking

width (float): with of the line

length (float): length of the line
    Default: 0
toffset (float): offset in t
    Default: 0
soffset (float): offset in s
    Default: 0
rule (MarkRule): mark rule (optional)

color (RoadMarkColor): color of line (optional)
</code></pre>
<h2 id="methods">Methods</h2>
<pre><code>get_element(elementname)
    Returns the full ElementTree of the class

get_attributes()
    Returns a dictionary of all attributes of FileHeader

add_roadmark(roadmark)
    adds a new roadmark to the lane
</code></pre>
<p>initalizes the Lane</p>
<h2 id="parameters_1">Parameters</h2>
<pre><code>marking_type (str): the type of marking

width (float): with of the line

length (float): length of the line
    Default: 0
toffset (float): offset in t
    Default: 0
soffset (float): offset in s
    Default: 0
rule (MarkRule): mark rule (optional)

color (RoadMarkColor): color of line
    Default: 'standard'
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RoadMark():
    &#34;&#34;&#34; creates a RoadMark of opendrive

        Parameters
        ----------
            marking_type (RoadMarkType): the type of marking

            width (float): with of the line

            length (float): length of the line
                Default: 0
            toffset (float): offset in t
                Default: 0
            soffset (float): offset in s
                Default: 0
            rule (MarkRule): mark rule (optional)

            color (RoadMarkColor): color of line (optional)

        Attributes
        ----------
            marking_type (str): the type of marking

            width (float): with of the line

            length (float): length of the line
                Default: 0
            toffset (float): offset in t
                Default: 0
            soffset (float): offset in s
                Default: 0
            rule (MarkRule): mark rule (optional)

            color (RoadMarkColor): color of line (optional)

        Methods
        -------
            get_element(elementname)
                Returns the full ElementTree of the class

            get_attributes()
                Returns a dictionary of all attributes of FileHeader

            add_roadmark(roadmark)
                adds a new roadmark to the lane

    &#34;&#34;&#34;
    def __init__(self,marking_type,width,length=0,space=0,toffset=0,soffset=0,rule=None,color=RoadMarkColor.standard):
        &#34;&#34;&#34; initalizes the Lane

        Parameters
        ----------
            marking_type (str): the type of marking

            width (float): with of the line

            length (float): length of the line
                Default: 0
            toffset (float): offset in t
                Default: 0
            soffset (float): offset in s
                Default: 0
            rule (MarkRule): mark rule (optional)

            color (RoadMarkColor): color of line
                Default: &#39;standard&#39;

        &#34;&#34;&#34; 
        self.marking_type = marking_type
        self.length = length
        self.space = space
        self.toffset = toffset
        self.rule = rule
        self.soffset = soffset
        self.width = width
        self.color = color
        #change default line values for broken lines 
        if marking_type == RoadMarkType.broken: 
            if self.length == 0:
                self.length = 3
            if self.space == 0: 
                self.space = 3
        self._line = RoadLine(self.width,self.length,self.space,self.toffset,self.soffset,self.rule,self.color)
        
        #TODO: add more inputs and check 1.5
        

    def get_attributes(self):
        &#34;&#34;&#34; returns the attributes of the Lane as a dict

        &#34;&#34;&#34;
        retdict = {}
        retdict[&#39;sOffset&#39;] = str(self.soffset)
        retdict[&#39;type&#39;] = enum2str(self.marking_type)
        retdict[&#39;weight&#39;] = enum2str(RoadMarkWeight.standard)
        retdict[&#39;color&#39;] = enum2str(self.color)
        retdict[&#39;sOffset&#39;] = str(self.soffset)
        retdict[&#39;width&#39;] = str(self.width)
        retdict[&#39;laneChange&#39;] = enum2str(LaneChange.none)
        retdict[&#39;height&#39;] = str(2e-02)
        return retdict

    def get_element(self):
        &#34;&#34;&#34; returns the elementTree of the WorldPostion

        &#34;&#34;&#34;
        element = ET.Element(&#39;roadMark&#39;,attrib=self.get_attributes())
        typeelement = ET.SubElement(element,&#39;type&#39;, attrib={&#39;name&#39;:enum2str(self.marking_type),&#39;width&#39;:str(self.width)})
        typeelement.append(self._line.get_element())
        return element</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pyodrx.lane.RoadMark.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the attributes of the Lane as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self):
    &#34;&#34;&#34; returns the attributes of the Lane as a dict

    &#34;&#34;&#34;
    retdict = {}
    retdict[&#39;sOffset&#39;] = str(self.soffset)
    retdict[&#39;type&#39;] = enum2str(self.marking_type)
    retdict[&#39;weight&#39;] = enum2str(RoadMarkWeight.standard)
    retdict[&#39;color&#39;] = enum2str(self.color)
    retdict[&#39;sOffset&#39;] = str(self.soffset)
    retdict[&#39;width&#39;] = str(self.width)
    retdict[&#39;laneChange&#39;] = enum2str(LaneChange.none)
    retdict[&#39;height&#39;] = str(2e-02)
    return retdict</code></pre>
</details>
</dd>
<dt id="pyodrx.lane.RoadMark.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the elementTree of the WorldPostion</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self):
    &#34;&#34;&#34; returns the elementTree of the WorldPostion

    &#34;&#34;&#34;
    element = ET.Element(&#39;roadMark&#39;,attrib=self.get_attributes())
    typeelement = ET.SubElement(element,&#39;type&#39;, attrib={&#39;name&#39;:enum2str(self.marking_type),&#39;width&#39;:str(self.width)})
    typeelement.append(self._line.get_element())
    return element</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pyodrx" href="index.html">pyodrx</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pyodrx.lane.Lane" href="#pyodrx.lane.Lane">Lane</a></code></h4>
<ul class="">
<li><code><a title="pyodrx.lane.Lane.add_link" href="#pyodrx.lane.Lane.add_link">add_link</a></code></li>
<li><code><a title="pyodrx.lane.Lane.add_roadmark" href="#pyodrx.lane.Lane.add_roadmark">add_roadmark</a></code></li>
<li><code><a title="pyodrx.lane.Lane.get_attributes" href="#pyodrx.lane.Lane.get_attributes">get_attributes</a></code></li>
<li><code><a title="pyodrx.lane.Lane.get_element" href="#pyodrx.lane.Lane.get_element">get_element</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyodrx.lane.LaneSection" href="#pyodrx.lane.LaneSection">LaneSection</a></code></h4>
<ul class="">
<li><code><a title="pyodrx.lane.LaneSection.add_left_lane" href="#pyodrx.lane.LaneSection.add_left_lane">add_left_lane</a></code></li>
<li><code><a title="pyodrx.lane.LaneSection.add_right_lane" href="#pyodrx.lane.LaneSection.add_right_lane">add_right_lane</a></code></li>
<li><code><a title="pyodrx.lane.LaneSection.get_attributes" href="#pyodrx.lane.LaneSection.get_attributes">get_attributes</a></code></li>
<li><code><a title="pyodrx.lane.LaneSection.get_element" href="#pyodrx.lane.LaneSection.get_element">get_element</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyodrx.lane.Lanes" href="#pyodrx.lane.Lanes">Lanes</a></code></h4>
<ul class="">
<li><code><a title="pyodrx.lane.Lanes.add_lanesection" href="#pyodrx.lane.Lanes.add_lanesection">add_lanesection</a></code></li>
<li><code><a title="pyodrx.lane.Lanes.get_element" href="#pyodrx.lane.Lanes.get_element">get_element</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyodrx.lane.RoadLine" href="#pyodrx.lane.RoadLine">RoadLine</a></code></h4>
<ul class="">
<li><code><a title="pyodrx.lane.RoadLine.get_attributes" href="#pyodrx.lane.RoadLine.get_attributes">get_attributes</a></code></li>
<li><code><a title="pyodrx.lane.RoadLine.get_element" href="#pyodrx.lane.RoadLine.get_element">get_element</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyodrx.lane.RoadMark" href="#pyodrx.lane.RoadMark">RoadMark</a></code></h4>
<ul class="">
<li><code><a title="pyodrx.lane.RoadMark.get_attributes" href="#pyodrx.lane.RoadMark.get_attributes">get_attributes</a></code></li>
<li><code><a title="pyodrx.lane.RoadMark.get_element" href="#pyodrx.lane.RoadMark.get_element">get_element</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>